
// Load the core node modules.
var CleanWebpackPlugin = require( "clean-webpack-plugin" );
var HtmlWebpackPlugin = require( "html-webpack-plugin" );
var path = require( "path" );
var webpack = require( "webpack" );

module.exports = {
	// I define the base-bundles that will be generated.
	// --
	// NOTE: Additional bundles may be created during optimization and code-splitting.
	entry: {
		polyfill: "./app/main.polyfill.ts",
		main: "./app/main.ts"
	},
	// I define the bundle file-name scheme.
	output: {
		filename: "[name].[chunkhash].js",
		path: path.join( __dirname, "build" )
	},
	resolve: {
		extensions: [ ".ts", ".js" ]
	},
	module: {
		rules: [
			{
				test: /\.ts$/,
				loaders: [ 
					// I compile the TypeScript content into ES5 JavaScript. In addition
					// to transpiling the code, it is also running type-checks based on 
					// the tsconfig.json file.
					"ts-loader",
					// Given the transpiled code, I convert Template and Style URL 
					// references into require() statements that will subsequently get 
					// consumed by the raw-loader.
					// --
					// NOTE: Do not include the "keepUrl=true" that is in some examples;
					// that inlines the content, but does not replace the property name
					// used in the component meta-data.
					"angular2-template-loader"
				]
			},
			// When the "angualr2-template-loader" runs, it will replace the @Component()
			// "templateUrl" and "styleUrls" with inline "require()" calls. As such, we
			// need the raw-loader so that require() will know how to load .htm and .css
			// file as plain-text.
			{ 
				test: /\.(htm|css)$/, 
				loader: "raw-loader"
			},
			// If our components link to .less files instead of .css files, then the
			// less-loader will parse the LESS CSS file on-the-fly during the require() 
			// call that is generated by the "angular2-template-loader".
			{
				test: /\.less$/,
				loaders: [
					"raw-loader",
					"less-loader"
				]
			}
		]
	},
	plugins: [
		// I clean the build directory before each build.
		new CleanWebpackPlugin([
			path.join( __dirname, "build/*.js" )
		]),

		// I generate the main "index" file and inject Script tags for the files emitted
		// by the compilation process.
		new HtmlWebpackPlugin({
			// Notice that we are saving the index UP ONE DIRECTORY, so that it is output
			// in the root of the demo.
			filename: "../index.htm",
			template: "./app/main.htm"
		})
	],
	optimization: {
		splitChunks: {
			// Apply optimization to all chunks, even initial ones.
			chunks: "all"
		}
	}
};
